import{_ as e,c as a,o as i,U as t}from"./chunks/framework.EUmXWpxD.js";const m=JSON.parse('{"title":"Searching - Types of Searching","description":"","frontmatter":{"layout":"doc","title":"Searching - Types of Searching","prev":{"text":"Introduction","link":"./introduction"},"next":{"text":"Examples of Searching","link":"./examples"}},"headers":[],"relativePath":"coba/meeting-12/typesofsearching.md","filePath":"coba/meeting-12/typesofsearching.md"}'),r={name:"coba/meeting-12/typesofsearching.md"},n=t('<h1 id="types-of-searching" tabindex="-1">Types of Searching <a class="header-anchor" href="#types-of-searching" aria-label="Permalink to &quot;Types of Searching&quot;">​</a></h1><h2 id="linear-searching" tabindex="-1">Linear Searching <a class="header-anchor" href="#linear-searching" aria-label="Permalink to &quot;Linear Searching&quot;">​</a></h2><ul><li>This method involves checking each element in a sequence one by one until the desired element is found or the entire sequence is traversed. It&#39;s simple but may be inefficient for large datasets. Time complexity: O(n).</li></ul><h2 id="binary-searching" tabindex="-1">Binary Searching <a class="header-anchor" href="#binary-searching" aria-label="Permalink to &quot;Binary Searching&quot;">​</a></h2><ul><li>Specifically for sorted arrays, this algorithm continually divides the dataset in half and checks if the desired element lies in the first or second half. It&#39;s highly efficient but requires the data to be sorted. Time complexity: O(log n).</li></ul><h2 id="hashing" tabindex="-1">Hashing <a class="header-anchor" href="#hashing" aria-label="Permalink to &quot;Hashing&quot;">​</a></h2><ul><li>Utilizes hash functions to map keys to their associated values in a data structure. It directly retrieves the element based on its hash value, making it very efficient for retrieval, especially in average-case scenarios. Time complexity: O(1) on average.</li></ul><h2 id="tree-based-searches" tabindex="-1">Tree-Based Searches <a class="header-anchor" href="#tree-based-searches" aria-label="Permalink to &quot;Tree-Based Searches&quot;">​</a></h2><ul><li>These searches involve storing elements in a hierarchical tree structure, facilitating efficient search by traversing the tree based on comparisons of values. Efficient for organized storage and search. Time complexity: O(log n) for balanced trees, but can degrade to O(n) for unbalanced ones.</li></ul>',9),s=[n];function o(c,h,l,d,f,g){return i(),a("div",null,s)}const p=e(r,[["render",o]]);export{m as __pageData,p as default};
